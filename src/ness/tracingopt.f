!//////////////////////////////////////////////////////////////////////
!////  $Id: tracingopt.f,v 1.19 2019/01/11 17:35:58 saroun Exp $
!////
!////  R E S T R A X - Simulation of neutron three-axis spectrometers
!////
!////     Copyright (C) 1995-2006, All rights reserved
!////     Nuclear Physics Institute AVCR, Rez, Czech Republic
!////     Institut Laue Langevin, Grenoble, France
!////
!////     Written by:  Jan Saroun
!////     $Revision: 1.19 $
!////     $Date: 2019/01/11 17:35:58 $
!//////////////////////////////////////////////////////////////////////
!////
!////  Ray-tracing options
!////
!//////////////////////////////////////////////////////////////////////
      MODULE TRACINGOPT
      use CLASSES
      use FIELDDEF
      use FIELDDATA
      USE SIMATH
      implicit none

! constants for TROPT%SAMPLING
      INTEGER, parameter :: rndist_uni=0
      INTEGER, parameter :: rndist_gauss=1
      INTEGER, parameter :: rndist_cauchy=2

! constants for TROPT%MODE (don't change order !!)
    ! TROPT%MODE decides on the way how the beamlines are traced
    ! 0 ... only PRIMARY beamline
    ! 1 ... only SECONDARY beamline, events generated by picking from STACK1
    ! 2 ... both beamlines in one cycle
      INTEGER, parameter :: tr_primary=0
      INTEGER, parameter :: tr_secondary=1
      INTEGER, parameter :: tr_all=2

! constants for TROPT%DIR (don't change order !!)
      INTEGER, parameter :: tr_downstream=0
      INTEGER, parameter :: tr_upstream=1

! constants for TROPT%PSMODE
      INTEGER, parameter :: tr_kspace=0 ! sampling in k-space
      INTEGER, parameter :: tr_lspace=1 ! sampling in lambda-space

! constants for TROPT%STORE
    ! TROPT%STORE decides what kind of final events to store
    ! 0 ... NEUI, NEUF1 (at the detector)
    ! 1 ... NEUI, NEUF (at the sample, for resolution function)
      INTEGER, parameter :: tr_detector=0
      INTEGER, parameter :: tr_sample=1



! structure with option data
      type TTROPT;sequence
        INTEGER :: CLASS                ! class ID
        character(LEN_ID)   :: ID       ! component ID string
        CHARACTER(LEN_NAME) :: NAME     ! descriptive name
  ! switches
        INTEGER :: DIR            ! down-stream tracing (set to -1 for up-stream)
        LOGICAL :: VARI           ! switch variance reduction
        LOGICAL :: MAXV           ! swicth max. value optimization
        LOGICAL :: SWPOOL         ! switch safety pool off after 1/2 counts accumulated
        LOGICAL :: DBC            ! separate tracing of primary and secondary parts
        LOGICAL :: MCSTAS         ! run mcstas in the middle part (only if there is no sample defined)

  ! variables controling event flow
        integer :: CNT     ! count target
    !    integer :: CNT_VARI      ! count target for variance reduction
    !    real(KIND(1.D0)) :: CNT_TOUT      ! count target for timeout
        real(KIND(1.D0)) :: PLIMIT ! target precision
        real(KIND(1.D0)) :: ELIMIT  ! limit for timeout on low efficiency
  ! tracing modes
        integer :: IMODE ! actually used mode in tracing procedure, tr_primary .. tr_all
        integer :: SPLIT ! number of cycles for the scattered beam (only if IMODE=tr_secondary)
        integer :: STORE ! storage mode (not used)
    ! parameters used in combined tracing mode (sample section run through McStas)
        real(KIND(1.D0)) :: PATHIN ! additional path to the sample axis, mm
        real(KIND(1.D0)) :: PATHOUT  ! additional path from the sample axis, mm
  ! sampling distribution
        integer :: SAMPLING
  ! choice of phase space variables
        integer :: PSMODE
  ! T0 is adjusted according for the passed slit at the T0 chopper
        LOGICAL :: ADJT0
  ! gravity in G_EARTH
        real(KIND(1.D0))  :: GRAVITY
      end type TTROPT

      TYPE(TTROPT) :: TROPT

      contains

C--------------------------------------------------------
      SUBROUTINE TROPT_DEFAULT(OBJ)
C Set default settings for tracing module
C These can be ovewritten by user before the call of TRACING_INI
C--------------------------------------------------------
      TYPE(TTROPT) :: OBJ
      OBJ%CLASS=OCLS_TRACING
      OBJ%DIR=tr_downstream
      OBJ%VARI=.FALSE.
      OBJ%MAXV=.TRUE.
      OBJ%SWPOOL=.TRUE.
      OBJ%DBC=.TRUE.
      OBJ%CNT=10000
      OBJ%ELIMIT=1.D5
      OBJ%PLIMIT=1.D-2
      OBJ%IMODE=tr_all
      OBJ%SPLIT=1
      OBJ%STORE=tr_detector
      OBJ%SAMPLING=rndist_uni
      OBJ%GRAVITY=1.D0
      OBJ%ADJT0=.false.
      OBJ%PATHIN=0.D0
      OBJ%PATHOUT=0.D0
      OBJ%MCSTAS=.false.
      END SUBROUTINE TROPT_DEFAULT

!---------------------------------------------------------
      SUBROUTINE TROPT_INP(OBJ,PNAME,ARG,NARG)
! input data from ARG to OBJ for parameter namespace PNAME
! INPUT
!    PNAME   .... parameter name
!    ARG     .... TFIELD parameter values
! INPUT
!    OBJ     .... SLIT structure
!    NARG    .... number of items read from ARG
!---------------------------------------------------------
      type(TTROPT) :: OBJ
      CHARACTER(*),intent(in) :: PNAME
      TYPE(TFIELD) :: ARG
      integer,intent(out) :: NARG
      integer :: LR
      real(KIND(1.D0)) :: NUM(FIELD_BUFFER_FLOAT)
      LR=0
      NARG=0
      select case(ARG%DEF%TID)
        case(ID_FIELD_FLOAT,ID_FIELD_INT,ID_FIELD_ENUM)
          call FIELD2ARRAY(ARG,0,NUM,FIELD_BUFFER_FLOAT,LR)
          call TROPT_INP_R(OBJ,trim(ARG%ID),NUM,LR)
        case default
          write(*,*) 'TROPT_INP: undefined field type '//trim(ARG%DEF%TID)
      end select
      NARG=LR
      END SUBROUTINE TROPT_INP


!---------------------------------------------------------
      SUBROUTINE TROPT_OUT(OBJ,PNAME,ARG,NARG)
! input data from ARG to OBJ for parameter namespace PNAME
! INPUT
!    PNAME   .... parameter name
!    ARG     .... TFIELD parameter values
! INPUT
!    OBJ     .... SLIT structure
!    NARG    .... number of items read from ARG
!---------------------------------------------------------
      type(TTROPT) :: OBJ
      CHARACTER(*),intent(in) :: PNAME
      TYPE(TFIELD) :: ARG
      integer,intent(out) :: NARG
      integer :: LR
      real(KIND(1.D0)) :: NUM(FIELD_BUFFER_FLOAT)
      LR=0
      NARG=0
      select case(ARG%DEF%TID)
        case(ID_FIELD_FLOAT,ID_FIELD_INT,ID_FIELD_ENUM)
          call TROPT_OUT_R(OBJ,trim(ARG%DEF%ID),NUM,LR)
          call ARRAY2FIELD(ARG,0,NUM,FIELD_BUFFER_FLOAT,LR)
        case default
          write(*,*) 'TROPT_OUT: undefined field type '//trim(ARG%DEF%TID)
      end select
      NARG=LR
      END SUBROUTINE TROPT_OUT

C---------------------------------------------------------
      SUBROUTINE TROPT_INP_R(OBJ,PNAME,ARG,NARG)
C input data from ARG to OBJ for TTROPT class
C INPUT
C    PNAME   .... parameter name
C    ARG     .... REAL*8 parameter values
C INPUT
C    OBJ     .... TTROPT structure
C    NARG    .... number of items read from ARG
C---------------------------------------------------------
      TYPE(TTROPT),intent(out) :: OBJ
      CHARACTER(*),intent(in) :: PNAME
      real(KIND(1.D0)), intent(in) :: ARG(*)
      integer,intent(out) :: NARG
      integer :: LR
      LR=1
      SELECT CASE (trim(PNAME))
      CASE('DIR');OBJ%DIR=NINT(ARG(1))
      CASE('VARI'); OBJ%VARI=(NINT(ARG(1)).eq.1)
      CASE('MAXV'); OBJ%MAXV=(NINT(ARG(1)).eq.1)
      CASE('SWPOOL'); OBJ%SWPOOL=(NINT(ARG(1)).eq.1)
      CASE('DBC'); OBJ%DBC=(NINT(ARG(1)).eq.1)
      CASE('MCSTAS'); OBJ%MCSTAS=(NINT(ARG(1)).eq.1)
      CASE('CNT'); OBJ%CNT=NINT(ARG(1))
      CASE('PLIMIT');   OBJ%PLIMIT=ARG(1)
      CASE('ELIMIT');   OBJ%ELIMIT=ARG(1)
      CASE('PATHIN');   OBJ%PATHIN=ARG(1)
      CASE('PATHOUT');   OBJ%PATHOUT=ARG(1)
      CASE('MODE'); OBJ%IMODE=NINT(ARG(1))
      CASE('SPLIT'); OBJ%SPLIT=NINT(ARG(1))
      CASE('STORE'); OBJ%STORE=NINT(ARG(1)); OBJ%STORE=tr_detector; ! fix to detector
      CASE('SAMPLING'); OBJ%SAMPLING=NINT(ARG(1))
      CASE('PSMODE'); OBJ%PSMODE=NINT(ARG(1))
      CASE('GRAVITY'); OBJ%GRAVITY=ARG(1)
      CASE('ADJT0'); OBJ%ADJT0=(NINT(ARG(1)).eq.1)
      END SELECT

      NARG=LR
      END SUBROUTINE TROPT_INP_R


C---------------------------------------------------------
      SUBROUTINE TROPT_OUT_R(OBJ,PNAME,ARG,NARG)
C output data from OBJ to ARG for TTROPT class
C INPUT
C    PNAME   .... parameter name
C    ARG     .... REAL*8 parameter values
C INPUT
C    OBJ     .... SLIT structure
C    NARG    .... number of items read from ARG
C---------------------------------------------------------
      TYPE(TTROPT),intent(in) :: OBJ
      CHARACTER(*),intent(in) :: PNAME
      real(KIND(1.D0)), intent(out) :: ARG(*)
      integer,intent(out) :: NARG
      integer :: LR
      LR=1
      SELECT CASE (trim(PNAME))
      CASE('DIR'); ARG(1)=OBJ%DIR
      CASE('VARI'); ARG(1)=LOG2INT(OBJ%VARI)
      CASE('MAXV'); ARG(1)=LOG2INT(OBJ%MAXV)
      CASE('SWPOOL'); ARG(1)=LOG2INT(OBJ%SWPOOL)
      CASE('DBC'); ARG(1)=LOG2INT(OBJ%DBC)
      CASE('MCSTAS'); ARG(1)=LOG2INT(OBJ%MCSTAS)
      CASE('CNT'); ARG(1)=OBJ%CNT
      CASE('PLIMIT');   ARG(1)=OBJ%PLIMIT
      CASE('ELIMIT');   ARG(1)=OBJ%ELIMIT
      CASE('PATHIN');   ARG(1)=OBJ%PATHIN
      CASE('PATHOUT');   ARG(1)=OBJ%PATHOUT
      CASE('MODE'); ARG(1)=OBJ%IMODE
      CASE('SPLIT'); ARG(1)=OBJ%SPLIT
      CASE('STORE'); ARG(1)=OBJ%STORE
      CASE('SAMPLING'); ARG(1)=OBJ%SAMPLING
      CASE('PSMODE'); ARG(1)=OBJ%PSMODE
      CASE('GRAVITY'); ARG(1)=OBJ%GRAVITY
      CASE('ADJT0');  ARG(1)=LOG2INT(OBJ%ADJT0)
      END SELECT
      NARG=LR
      END SUBROUTINE TROPT_OUT_R

      end module TRACINGOPT


